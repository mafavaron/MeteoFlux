#!/usr/bin/python

# almpro.py - DL system's Alarm Processor
#
# Copyright 2012 by Servizi Territorio srl
#                   All rights reserved
#
# By: Mauri Favaron
#     ST/R&D

# Warning. Newbies have typically a mental image which is very simple, but wrong.
# On the contrary, alarm-related logics is quite involved, and might result in a
# large, messy tree of predicates if first-in-the-mind intuition is left free riding.
#
# Here a more disciplined path is followed (building on the author's experience
# on large scale supervisory control systems, in 1988-1995 - random events may
# sometimes carry random benefits).
#
# As a consequence some parts of this code (namely monitor class and its subclasses)
# may sometimes be involved - extensive comments can be found in these cases however.
#
# A question might arise on "why this degree of trickiness". The answer is in the
# possibility to specify a sampling time as long as 60 seconds, so much to allow
# very large variable changes, sweeping from, say, a HH to LL alarm condition in a single
# step. Events like these should be "alarmed" whenever detected, which the most diffused
# first-in-mind fails to notice.

# The alarm processor is a part of DL running as a separate thread, and in charge
# of notifying "alarm events" to interested users, through a safe
# but possibly slow" channel (writing alarms to
# hourly failure files remote users can access remotely at will), and a "fast but
# not guaranteed to arrive" channel (like e-mail and/or SMS).
#
# The alarm processor operates on "alarm events", issued by "monitors" also
# defined in this module. "Monitors" are user API functions which test data and
# states for alarm conditions and issue them in orderly through the alarm queue.
#
# Alarm emission by user-level API is always logger to the machine journal, along
# with any failure during alarm notification. But *not alarms themselves*!
#
# The alarm processor (intentionally) does not support alarm acknowledge. All what
# happens to alarms is they are notified.

import threading
import Queue
import time
import os
import smtplib
from email.mime.text import MIMEText

import local_site
import msglog

# Common configuration parameters

_from  = "meteofluxcore@serviziterritorio.it"
_to    = ""
_phone = ""

def SetEmailOrigin(stationName):
	
	global _from
	
	_from = "%s@serviziterritorio.it" % stationName
	
def GetEmailOrigin():
	
	global _from
	
	return _from

def SetEmailDestinations(destinationAddresses):
	
	global _to
	
	_to = destinationAddresses
	
def GetEmailDestinations():
	
	global _to
	
	return _to
	
def SetPhoneNumber(phone):
	
	global _phone
	
	_phone = phone

def GetPhoneNumber():
	
	global _phone
	
	return _phone

# Alarm class

class Alarm(object):
	
	def __init__(self, timeStamp, txt, severity, email, phone):
		
		self._text      = txt
		self._severity  = severity
		self._email     = email
		self._phone     = phone
		self._timeStamp = timeStamp
		
	def SendEmail(self):
		
		global _from
		
		# Check something is to be made
		if len(self._email) > 0:
			
			# More recipients might be specified
			to = self._email.split(",")
			
			# Set other parameters, and compose message text
			msg = ("From: %s\r\nTo: %s\r\n\r\n" % (_from, ", ".join(to)))
			msg = "This alarm has been automatically generated by Meteoflux Core. Please do not reply. Alarm text follows on next line:\n\n"
			msg += self._text
			almMessage = MIMEText(msg)
			almMessage['Subject'] = "Meteoflux Core: Alarm"
			almMessage['From']    = _from
			almMessage['To']      = _to
			
			
			# Try actually sending emails
			result = True
			try:
				mailServer = smtplib.SMTP(local_site.SMTP_SERVER)
			except smtplib.SMTPConnectError:
				msglog.logMessage("Warning - Connection to e-mail server %s failed" % local_site.SMTP_SERVER)
				return False
			mailServer.set_debuglevel(0)
			try:
				mailServer.sendmail(_from, _to.strip(), almMessage.as_string())
			except smtplib.SMTPRecipientsRefused:
				msglog.logMessage("Warning - None of destinations (%s) is acceptable" % self._email)
				mailServer.quit()
				return False
			except smtplib.SMTPHeloError:
				msglog.logMessage("Warning - e-mail server %s not operational" % local_site.SMTP_SERVER)
				mailServer.quit()
				return False
			except smtplib.SMTPSenderRefused:
				msglog.logMessage("Warning - Sender (%s) is not acceptable" % _from)
				mailServer.quit()
				return False
			except smtplib.SMTPDataError:
				msglog.logMessage("Warning - Data error flagged by server %s" % local_site.SMTP_SERVER)
				mailServer.quit()
				return False
				
			mailServer.quit()
					
		else:
			
			result = True
			
		return result
		
	def SendSMS(self):
		
		pass
		
	def getText(self):
		
		return self._text
		
	def getTimeStamp(self):
		
		return self._timeStamp
		

# Alarm processor thread

_almQueue = Queue.Queue(0)

def StopAlarmProcessor():
	global _almQueue
	_almQueue.put(None)

class AlarmProcessor(threading.Thread):
	
	def __init__(self):
		global _almQueue
		self._queue = _almQueue
		threading.Thread.__init__(self)
		
	def run(self):
		while 1:
			
			# Get one alarm from queue
			alm = self._queue.get()
			if alm is None:
				break	# This is queue end
				
			# Append to the appropriate "failures" file depending on alarm's time stamp.
			# This is found in the first part of alarm text.
			tm = time.gmtime(alm.getTimeStamp())
			dirName = local_site.ALARM_LISTS_PATH + "/%04d%02d" % (tm.tm_year, tm.tm_mon)
			try:
				os.mkdir(dirName)
			except OSError:
				pass
			fileName = dirName + "/ALARM_%04d%02d%02d%02d.txt" % (tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour)
			f = open(fileName, "a")
			f.write(alm.getText() + "\n")
			f.close()
			
			# Notify alarm remotely
			result = alm.SendEmail()
			if not result:
				# Log notification failure
				pass
				
			result = alm.SendSMS()
			if not result:
				# Log notification failure
				pass
				

# User level indicators

SEVERITY_NONE = 0
SEVERITY_LOW  = 1
SEVERITY_HIGH = 2

class Monitor(object):
	
	# Class members
	_minimumSeverity = SEVERITY_HIGH		# Only important events are issued
	_emailAddress    = ""					# e-mail address to which alarm events are issued
	_phoneNumber     = ""					# Phone number to which SMS messages are addressed 
	
	def __init__( self, message ):
		
		self._timeStamp    = ""
		self._oldState     = False			# No issue on start
		self._currentState = False			# No issue on start
		self._severity     = SEVERITY_NONE	# No issue on start
		self._oldSeverity  = SEVERITY_NONE	# No issue on start
		self._direction    = ""
		self._message      = message		# The text to incorporate in alarm
		
	def SetNotification(self, eMail, phoneNumber):
		
		self._emailAddress = eMail
		self._phoneNumber  = phoneNumber
		
	def GetEmailNotificationAddress(self):
		
		return self._emailAddress
		
	def GetPhoneNotificationNumber(self):
		
		return self._phoneNumber
		
	def notify( self, message ):
		"""
		Notify message as it is, not updating the corresponding member.
		This routine is usually invoked by subclasses to log their own
		alarms.
		"""
		
		global _to
		global _phone
		global _almQueue
		
		# Get time stamp
		eventTime = time.time()
		tm = time.gmtime(eventTime)
		self._timeStamp = eventTime
		
		if self._emailAddress == "":
			email = _to
		else:
			email = self._emailAddress
		if self._phoneNumber == "":
			phone = _phone
		else:
			phone = self._phoneNumber
		if tm is not None:
			timeText = "%04d-%02d-%02d %02d:%02d:%02d" % (tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec)
		else:
			timeText = "<No Time stamp>"
		alarmText = "%s - %s" % (timeText, message)
		if self._severity >= self._minimumSeverity:
			# Important alarm: log internally and notify
			alm = Alarm(self._timeStamp, alarmText, self._severity, email, phone)
		else:
			# Less important alarm: just log internally, do not notify
			alm = Alarm(self._timeStamp, alarmText, self._severity, "", "")
		_almQueue.put(alm)
		
		
class AnalogMonitor(Monitor):
	
	def __init__(self, message, ll, l, h, hh):
		
		q = [ll,l,h,hh]
		q.sort()
		self._ll = q[0]
		self._l  = q[1]
		self._h  = q[2]
		self._hh = q[3]
		
		self._oldValue = None
		
		Monitor.__init__(self, message)
		
	def checkValue(self, value):
		
		# Initialize state names (will be used later)
		nm = ["Very Low", "Low", "Normal", "High", "Very High"]
		
		# Let's assume we have four thresholds, sorted in ascending order:
		q = [self._ll, self._l, self._h, self._hh]
		q.sort()
			
		# Generate current state and severity, by comparing value with thresholds. This is made
		# the non-simplicistic way, by checking how many thresholds have been crossed since old
		# value, and generating more alarms if needed.
		if self._oldValue is not None:
			
			# Now, we have two values, an old and a current one. They define a "path"
			# (whose timing is unrelevant to the application - and then whose time
			# stamps may all be identical), from "old" to "new".
			# During this path, some or more boundaries may be crossed. As we shall see
			# quite soon, a fair manner to describe these paths is by just their initial and
			# final states.
			#
			# As a first step a table lookup for old and current values is made, and indices
			# are derived according to this rule:
			#
			#	Predicate					Index
			#
			#	value <= ll					  0
			#	ll < value <= l				  1
			#	l < value < h				  2
			#	h <= value < hh				  3
			#	value >= hh					  4
			#
			# Other steps will be explained soon after.
			
			oldIndex = posSearch(q, self._oldValue)
			newIndex = posSearch(q, value)
			
			# Now: because of the scheme adopted, the number of boundaries crossed equals
			# the absolute value of the difference between new and old indices. A language is
			# needed to describe succintly what happened.
			#
			# The way adopted in Meteorlux Core is a simple one: alarm conditions are labeled
			# by their initial and final states automatically, e.g. as "LL to H". This kind of
			# transition is equivalent to the longer sequence
			#
			#	LL to L
			#	L to Normal
			#	Normal to H
			#
			# Severity, on the other side, is assigned according to new index, according to
			# the following table:
			#
			#	newIndex	severity
			#		0			SEVERITY_HIGH
			#		1			SEVERITY_LOW
			#		2			SEVERITY_NONE
			#		3			SEVERITY_LOW
			#		4			SEVERITY_HIGH
			#
			# By coincidence, this is the same as saying 'severity' equals the absolute
			# difference between 'newIndex' and 2, corresponding to "normal" state.
			#
			# Why so? My answer is that in this way we give a purely factual description
			# of the system evolution, up to the discretization implied in the choice of a
			# finite sampling step. A sequence, like LL->L, L->N, N->H suggests an *evolution*,
			# this misleading users to exclude possibilities like LL>L>N>L>N>H>HH>H.
			self._severity = abs(newIndex - 2)
			if newIndex != oldIndex:
				
				msg = "%s to %s - %s" % (nm[oldIndex], nm[newIndex], self._message)
				Monitor.notify(self, msg)
				
		else:
			
			# Initial case: issue an alarm only based on current value
			newIndex = posSearch(q, value)
			if newIndex != 2:
				
				msg = "%s - %s" % (nm[newIndex], self._message)
				Monitor.notify(self, msg)
		
		# Update old value, waiting the next invocation
		self._oldValue = value
				
				
def posSearch(q, value):
	
	if q[1] < value and value < q[2]:
		
		index = 2
		
	elif q[0] < value and value <= q[1]:
		
		index = 1
		
	elif q[2] < value and value <= q[3]:
		
		index = 3
		
	elif value <= q[0]:
		
		index = 0
		
	elif value >= q[3]:
		
		index = 4
			
	return index
	
	
class StateMonitor(Monitor):
	
	def __init__(self, message, invalidState):
		
		self._invalidState = invalidState
		
		self._oldState = None
		
		Monitor.__init__(self, message)
		
	def checkValue(self, state):
		
		global SEVERITY_HIGH
		
		# Generate current state and severity, by comparing value with "invalid" state.
		if self._oldState is not None:
			
			self._severity = SEVERITY_HIGH
			if state != self._oldState:
				
				if state == self._invalidState:
					msg = "Entering - %s" % self._message
				else:
					msg = "Exiting - %s" % self._message
				Monitor.notify(self, msg)
				
		else:
			
			# Initial case: issue an alarm only based on current value
			if state == self._invalidState:
				
				msg = "Entering - %s" % self._message
				Monitor.notify(self, msg)
		
		# Update old value, waiting the next invocation
		self._oldState = state
				
				
def posSearch(q, value):
	
	if q[1] < value and value < q[2]:
		
		index = 2
		
	elif q[0] < value and value <= q[1]:
		
		index = 1
		
	elif q[2] < value and value <= q[3]:
		
		index = 3
		
	elif value <= q[0]:
		
		index = 0
		
	elif value >= q[3]:
		
		index = 4
			
	return index
	
# Test driver

if __name__ == "__main__":

	# Email addresses, valid for all specific alarms (simple case; used whenever alarm-specific email addresses are not specified)
	SetEmailOrigin(stationName = "prova")
	SetEmailDestinations(destinationAddresses = "mafavaron@mac.com")
	
	threads = []
	
	print "A"
	
	thread = AlarmProcessor()
	thread.start()
	threads.append(thread)
	print "B"
	
	a = AnalogMonitor("Keteltemperatur", -10.0, -5.0, 5.0, 10.0)
	b = StateMonitor("Valve WXX: excessive pressure", True)

	b.checkValue(False)
	
	a.checkValue(100.0)
	
	a.checkValue(0.0)
	
	a.checkValue(7.0)
	
	b.checkValue(True)
	
	a.checkValue(-30.0)
	
	a.checkValue(30.0)
	
	b.checkValue(True)
	
	a.checkValue(7.0)
	
	b.checkValue(False)
	
	a.checkValue(0.0)
	
	print "C"
	
	StopAlarmProcessor()
	
	thread.join()
	
